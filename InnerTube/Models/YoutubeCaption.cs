using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;

namespace InnerTube.Models
{
	// Most field names here are just guesses on what they could mean.
	public class YoutubeCaption
	{
		[JsonProperty("events")] public IReadOnlyList<CaptionEvent> Events;
		[JsonProperty("pens")] public IReadOnlyList<CaptionPen> Pens;
		[JsonProperty("wpWinPositions")] public IReadOnlyList<WinPosition> WinPositions;
		[JsonProperty("wpWinStyles")] public IReadOnlyList<WinStyle> WinStyles;
		[JsonProperty("wireMagic")] public string WireMagic;

		public class CaptionEvent
		{
			[JsonProperty("dDurationMs")] public int? DurationMs;
			[JsonProperty("tStartMs")] public int? StartMs;
			[JsonProperty("pPenId")] public int? PenId;
			[JsonProperty("wpWinPosId")] public int? WinPositionId;
			[JsonProperty("wsWinStyleId")] public int? WinStyleId;
			[JsonProperty("segs")] public IReadOnlyList<CaptionSegment> Segments;

			private string MsToTimestamp(int ms) => TimeSpan.FromMilliseconds(ms).ToString("h\\:mm\\:ss\\.ff");

			public string GetDialogue(string name = "")
			{
				StringBuilder sb = new("");
				sb.Append(
					$"Dialogue: 0, {MsToTimestamp(StartMs ?? 0)}, {MsToTimestamp((StartMs ?? 0) + (DurationMs ?? 0))}, pen{PenId ?? 0},{name},0,0,0,,");

				foreach (CaptionSegment segment in Segments)
					sb.Append(segment.PenId is not null
						? $"{{\\rpen{segment.PenId}}}{segment.Text}"
						: $"{segment.Text}");

				return sb.ToString();
			}
		}

		public class CaptionSegment
		{
			[JsonProperty("pPenId")] public int? PenId;
			[JsonProperty("utf8")] public string Text;
		}

		public class CaptionPen
		{
			[JsonProperty("bAttr")] public int? BAttribute;
			[JsonProperty("boBackAlpha")] public int? BackgroundAlpha;
			[JsonProperty("ecEdgeColor")] public int? EdgeColor;
			[JsonProperty("etEdgeType")] public int? EdgeType;
			[JsonProperty("fcForeColor")] public int? ForegroundColor;
			[JsonProperty("foForeAlpha")] public int? ForegroundAlpha;
			[JsonProperty("fsFontStyle")] public int? FontStyle;
			[JsonProperty("iAttr")] public int? IAttribute;
			[JsonProperty("szPenSize")] public int? PenSize;

			private string GetColorFromInt(int alpha, int color)
			{
				string rgb = Convert.ToString(color, 16);
				while (rgb.Length < 6) rgb = "0" + rgb;
				if (rgb.Length > 6) rgb = "ffffff";

				string a = Convert.ToString(alpha, 16);
				while (a.Length < 2) a = "0" + a;
				if (a.Length > 2) a = "ff";
				
				/*
				 * The hex in foregroundRgb is RRGGBB but the SSA specification requires it in BBGGRR format
				 * who did this 😂👌
				 */
				return $"{a}{rgb[4..6]}{rgb[2..4]}{rgb[0..2]}";
			}

			public string GetStyle(string name)
			{

				return $"Style: {name}," +
				       /* Fontsize */			$"Arial,{PenSize ?? 20}," +
				       /* PrimaryColour */		$"&H{GetColorFromInt(ForegroundAlpha ?? 0, ForegroundColor ?? 0)}," +
				       /* SecondaryColour */	$"&H{GetColorFromInt(ForegroundAlpha ?? 0, ForegroundColor ?? 0)}," +
				       /* OutlineColour */		$"&H{GetColorFromInt(BackgroundAlpha ?? 0, 0)}," +
				       /* BackColour */			$"&H{GetColorFromInt(BackgroundAlpha ?? 0, 0)}," +
				       /* Bold */				"0," +
				       /* Italic */				"0," +
				       /* Underline */			"0," +
				       /* StrikeOut */			"0," +
				       /* ScaleX */				"100," +
				       /* ScaleY */				"100," +
				       /* Spacing */			"0," +
				       /* Angle */				"0," +
				       /* BorderStyle */		"1," +
				       /* Outline */			"2," +
				       /* Shadow */				"0," +
				       /* Alignment */			"2," +
				       /* MarginL */			"10," +
				       /* MarginR */			"10," +
				       /* MarginV */			"10," +
				       /* Encoding */			"1";
			}
		}

		public class WinPosition
		{
			[JsonProperty("ahHorPos")] public int? HorizontalPosition;
			[JsonProperty("avVerPos")] public int? VerticalPosition;
			[JsonProperty("apPoint")] public int? Point;
		}

		public class WinStyle
		{
			[JsonProperty("juJustifCode")] public int? JustificationCode;
			[JsonProperty("pdPrintDir")] public int? PrintDirection;
			[JsonProperty("sdScrollDir")] public int? ScrollDirection;
		}

		public string ConvertToSubStationAlpha()
		{
			StringBuilder sb = new();
			
			// Header
			sb
				.AppendLine("[Script Info]")
				.AppendLine("; Script generated by InnerTube")
				.AppendLine("; https://gitlab.com/kuylar/LightTube")
				.AppendLine("Title: YouTube Subtitle")
				.AppendLine("ScriptType: v4.00+")
				.AppendLine("WrapStyle: 0")
				.AppendLine("ScaledBorderAndShadow: yes")
				.AppendLine("YCbCr Matrix: None")
				.AppendLine("PlayResX: 640")
				.AppendLine("PlayResY: 480")
				.AppendLine("");
			
			// YouTube Pens -> SSA Styles
			sb.AppendLine("[V4+ Styles]")
				.AppendLine("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");
			for (int i = 0; i < Pens.Count; i++)
			{
				CaptionPen pen = Pens[i];
				sb.AppendLine(pen.GetStyle("pen" + i));
			}
			sb.AppendLine("");
			
			// YouTube Segments -> SSA Events
			sb.AppendLine("[Events]")
				.AppendLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
			foreach (CaptionEvent captionEvent in Events) sb.AppendLine(captionEvent.GetDialogue());


			return sb.ToString();
		}
	}
}