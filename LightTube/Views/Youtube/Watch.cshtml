@using System.Collections.Specialized
@using System.Globalization
@using System.Web
@using YTProxy.Models
@model LightTube.Contexts.PlayerContext

@{
	ViewBag.Metadata = new Dictionary<string, string>();
	ViewBag.Metadata["author"] = Model.Player.Channel.Name;
	ViewBag.Metadata["og:title"] = Model.Player.Title;
	ViewBag.Metadata["og:url"] = $"{Url.ActionContext.HttpContext.Request.Scheme}://{Url.ActionContext.HttpContext.Request.Host}{Url.ActionContext.HttpContext.Request.Path}{Url.ActionContext.HttpContext.Request.QueryString}";
	ViewBag.Metadata["og:image"] = $"{Url.ActionContext.HttpContext.Request.Scheme}://{Url.ActionContext.HttpContext.Request.Host}/proxy?url={HttpUtility.UrlEncode(Model.Player.Thumbnails.FirstOrDefault()?.Url?.ToString())}";
	ViewBag.Metadata["twitter:card"] = $"{Url.ActionContext.HttpContext.Request.Scheme}://{Url.ActionContext.HttpContext.Request.Host}/proxy?url={HttpUtility.UrlEncode(Model.Player.Thumbnails.LastOrDefault()?.Url?.ToString())}";
	ViewBag.Metadata["og:description"] = Model.Player.Description;
	ViewBag.Title = Model.Player.Title;
	Layout = "_Layout";
	bool live = Model.Player.Formats.Length == 0 && Model.Player.AdaptiveFormats.Length > 0;
	try
	{
		ViewBag.Metadata["og:video"] = $"/proxy?url={HttpUtility.UrlEncode(Model.Player.Formats.First().Url.ToString())}";
		Model.Resolution ??= Model.Player.Formats.First().FormatNote;
	}
	catch
	{
		
	}
	ViewData["DisableOldCss"] = true;
	ViewData["HideGuide"] = true;
}

<!-- TODO: chapters -->
<div class="watch-page">
	<div class="primary">
		<div class="video-player-container">
			@if (Model.Player.Formats.Length > 0 || live)
			{
				@if (live)
				{
					<video id="player" class="video-js player" poster="@Model.Player.Thumbnails.Last().Url" controls>
						@foreach (AdaptiveFormat format in Model.Player.AdaptiveFormats.Reverse())
						{
							@:<source label='@format.Resolution.Split("x")[1]P' src='/subtitle_proxy?url=@HttpUtility.UrlEncode(format.Url.ToString())' type="application/x-mpegURL">
						}

						@foreach (Subtitle subtitle in Model.Player.Subtitles)
						{
							@:<track src="/subtitle_proxy?url=@HttpUtility.UrlEncode(subtitle.Url.ToString())" label="@subtitle.Language" kind="subtitles">
						}
					</video>
				}
				else
				{
					<video id="player" class="video-js player" src="/proxy?url=@HttpUtility.UrlEncode(Model.Player.Formats.First(x => x.FormatNote == Model.Resolution).Url.ToString())" poster="@Model.Player.Thumbnails.Last().Url" controls>
						@foreach (Subtitle subtitle in Model.Player.Subtitles)
						{
							@:<track src="/subtitle_proxy?url=@HttpUtility.UrlEncode(subtitle.Url.ToString())" label="@subtitle.Language" kind="subtitles">
						}
					</video>
				}
			}
			else
			{
				<div id="player" class="error" style="background-image: url('@Model.Player.Thumbnails.LastOrDefault()?.Url')">
					@if (string.IsNullOrWhiteSpace(Model.Player.ErrorMessage))
					{
						<span>
							No playable streams returned from the API (@Model.Player.Formats.Length/@Model.Player.AdaptiveFormats.Length)
						</span>
					}
					else
					{
						<span>
							@Model.Player.ErrorMessage
						</span>
					}
				</div>
			}
		</div>
		<div class="video-info">
			<div class="video-title">@Model.Player.Title</div>
			<div class="video-info-bar">
				<span>@Model.Player.Engagement.Views views</span>
				<span>Published @DateTimeOffset.Parse(Model.Player.UploadDate, null, DateTimeStyles.RoundtripKind).ToString("MMM dd, yyyy")</span>
				<div class="divider"></div>
				<div class="engagement-container">
					<div class="engagement-info">
						<span class="likes"><img src="icons/like.svg">@Model.Player.Engagement.Likes</span>
						<span class="dislikes"><img src="icons/dislike.svg">@Model.Player.Engagement.Dislikes</span>
					</div>
					<div class="engagement-bar">
						<div style="width: @(Model.Player.Engagement.GetLikePercentage().ToString().Split(".")[0])%"></div>
					</div>
				</div>
				<a href="https://www.youtube.com/watch?v=@Model.Player.Id">YouTube link</a>
			</div>
			<div class="channel-info">
				<a href="/channel/@Model.Player.Channel.Id" class="avatar">
					<img src="@Model.Player.Channel.Avatars.Last().Url">
				</a>
				<div class="name">
					<a href="/channel/@Model.Player.Channel.Id">@Model.Player.Channel.Name</a>
				</div>
				<button class="subscribe-button" data-cid="@Model.Player.Channel.Id">Subscribe</button>
			</div>
			<p class="description">@Html.Raw(Model.Player.GetHtmlDescription())</p>
		</div>
		<hr>
	</div>
	<div class="secondary">
		<noscript>
			<div class="resolutions-list">
				<h3>Change Resolution</h3>
				<div>
					@foreach (AdaptiveFormat format in Model.Player.Formats)
					{
						@if (format.FormatNote == Model.Resolution)
						{
							<b>@format.FormatNote (current)</b>
						}
						else
						{
							<a href="/watch?v=@Model.Player.Id&quality=@format.FormatNote">@format.FormatNote</a>
						}
					}
				</div>
			</div>
		</noscript>
		<div class="recommended-list">
			
			@if (Model.Player.Recommended.Length == 0)
			{
				<p style="text-align: center">None :(<br>This is most likely an age-restricted video</p>
			}
			@foreach (ItemPreview recommendation in Model.Player.Recommended)
			{
				Preview itemPreview = recommendation.GetPreview();
				switch (itemPreview)
				{
					case VideoPreview video:
						<div class="video">
							<a href="/watch?v=@video.Id" class="thumbnail" style="background-image: url('@video.Thumbnails.Last().Url')">
								<span class="video-length">@video.Duration</span>
							</a>
							<div class="info">
								<a href="/watch?v=@video.Id" class="title max-lines-2">@video.Title</a>
								<div>
									<a href="/channel/@video.Channel.Id" class="max-lines-1">@video.Channel.Name</a>
									<div>
										<span>@video.Views views</span>
										<span>â€¢</span>
										<span>@video.UploadedAt</span>
									</div>
								</div>
							</div>
						</div>
						break;
					case PlaylistPreview playlist:
						<div class="playlist">
							<a href="/watch?v=@playlist.FirstVideoId&list=@playlist.Id" class="thumbnail" style="background-image: url('@playlist.Thumbnails.First().Url')">
								<div>
									<span>@playlist.VideoCount</span>
									<span>VIDEOS</span>
								</div>
							</a>
							<div class="info">
								<a href="/watch?v=@playlist.FirstVideoId&list=@playlist.Id" class="title max-lines-2">@playlist.Title</a>
								<div>
									<a href="/channel/@playlist.Channel.Id">@playlist.Channel.Name</a>
								</div>
							</div>
						</div>
						break;
					default:
						<div class="video">
							<div class="thumbnail" style="background-image: url('@itemPreview.Thumbnails.Last().Url')"></div>
							<div class="info">
								<span class="title max-lines-2">@itemPreview.Title</span>
								<div>
									<b>WARNING:</b> Unknown recommendation type: @recommendation.Type
								</div>
							</div>
						</div>
						break;
				}
			}
		</div>
	</div>
</div>

@if (Model.Player.Formats.Length > 0 || live)
{
	<script src="~/js/videojs/video.js"></script>
	<script src="~/js/videojs/videojs-quality-selector.js"></script>
	<script src="~/js/videojs/videojs-audio.js"></script>
	<script src="~/js/videojs/videojs-hotkeys.js"></script>
	<script>
	const player = videojs('player', {
		controlBar: {
			children: [
				'playToggle',
				'volumePanel',
				'currentTimeDisplay',
				'timeDivider',
				'durationDisplay',
				'liveDisplay',
				'seekToLive',
				'progressControl',
				'spacer',
				'chaptersButton',
				'subsCapsButton',
				'playbackRateMenuButton',
				'qualitySelector',
				'pictureInPictureToggle',
				'fullscreenToggle',
			],
		},
		plugins: {
			"audio": {
				audioTracks: [
					@foreach (AdaptiveFormat format in Model.Player.AdaptiveFormats.Where(x => x.Resolution == "audio only").Reverse().GroupBy(x => x.FormatNote)
						.Select(g => g.First()))
					{
						NameValueCollection query = HttpUtility.ParseQueryString(format.Url.Query);

						@:{src: '/proxy?url=@HttpUtility.UrlEncode(format.Url.ToString())'},
					}
				],
				syncInterval: 10000
			},
		}
	}).ready(function() {
		this.src([
			@foreach (AdaptiveFormat format in Model.Player.AdaptiveFormats.Where(x => x.Resolution != "audio only" && x.Format != "144p").Reverse().GroupBy(x => x.FormatNote)
				.Select(g => g.First()))
			{
				NameValueCollection query = HttpUtility.ParseQueryString(format.Url.Query);

				@:{src: '/proxy?url=@HttpUtility.UrlEncode(format.Url.ToString())',type: '@query.Get("mime")',label: '@format.FormatNote', selected: @(format.FormatNote.StartsWith("720p") ? "true" : "false")},
			}
        ]);
        this.hotkeys({
          volumeStep: 0.1,
          seekStep: 5,
          enableModifiersForNumbers: false,
          enableVolumeScroll: false
        });
      });
	</script>
}
